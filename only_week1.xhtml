<document>

<div class="navigation">



</div>

<div><p>
<course number="8.370r" display_name="Quantum Info Science I" attrib_string="semester=2017_Fall"><p>
<chapter display_name="Unit 1: Quantum and classical computing fundamentals" attrib_string="url_name=unit1" linenum="46" tex_filename="./week1.tex" refnum="1"><p>
<askta>settings=1 to=rtakagi@mit.edu cc=ichuang@mit.edu</askta> </p><p>
<sequential display_name="Lectures U1.1: History and development of quantum computation" attrib_string="" linenum="3" tex_filename="./week1_lectures1.tex" refnum="1"><p>
<vertical display_name="About Unit 1" attrib_string="" refnum="1"><p>
<html display_name="About Unit 1" attrib_string="" linenum="9" tex_filename="./week1_lectures1.tex"><p>
<big class="xxlarge">About Unit 1</big> </p><p>
<b class="bf">Lecture Topics:</b> Introduction to quantum computation; classical Boolean logic; introduction to quantum mechanics; quantum wierdness. </p><p>
We begin this course with an overview of quantum computation, then build a foundation for the semester by describing the basic tenets of classical computing, based on Boolean logic. We then present the fundamental principles of quantum mechanics, in the context of quantum computation, based on four postulates governing states, time-evolution of states, measurement, and tensor products of states. We then illustrate some of the strangest, non-classical features of quantum mechanics, many of which arise in the context of a property known as quantum entanglement. </p><p>
 <br /><b class="bf">Optional Reading:</b> <a href="https://www.amazon.com/Quantum-Computation-Information-10th-Anniversary/dp/1107002176" target="_blank">Nielsen and Chuang</a>, Chapter 1 </p></html> </p><p>
<html display_name="" attrib_string="url_name=site_search_box1" linenum="35" tex_filename="./week1_lectures1.tex"><p>
<edxinclude linenum="35" filename="./week1_lectures1.tex">XML/add_site_search_box.xml</edxinclude> </p></html> </p></vertical> </p><p>
<vertical display_name="Course topics for the semester" attrib_string="" refnum="2"><p>
<video display_name="Course topics for the semester" youtube_id_1_0="mkEzEkrqrlk" attrib_string="url_name=U1L1a"></video><html display_name="" attrib_string="url_name=site_search_box2" linenum="45" tex_filename="./week1_lectures1.tex"><p>
<edxinclude linenum="45" filename="./week1_lectures1.tex">XML/add_site_search_box.xml</edxinclude> </p></html> </p></vertical> </p><p>
<vertical display_name="Models for classical computation" attrib_string="" refnum="3"><p>
<video display_name="Models for classical computation" youtube_id_1_0="BM4hlDQsc1M" attrib_string="url_name=U1L1b"></video><html display_name="" attrib_string="url_name=site_search_box3" linenum="57" tex_filename="./week1_lectures1.tex"><p>
<edxinclude linenum="57" filename="./week1_lectures1.tex">XML/add_site_search_box.xml</edxinclude> </p></html> </p></vertical> </p><p>
<vertical display_name="CQ: Models for classical computation" attrib_string="" refnum="4"><p>
<problem display_name="Universality of classical circuits" attrib_string="url_name=u1-1-cq-universality attempts=1" linenum="65" tex_filename="./week1_lectures1.tex"><p>
This is a concept question, provided to double-check your understanding of the previous video clip. </p><p>
In lecture, Prof. Shor introduced the topic of universality, and described how some models of classical computation which are universal, and other models are not. </p><p>
The circuit model of classical computation may be defined as the family of electrical circuits composed from AND gates and NOT gates. </p><p>
Check all the following which are true for the circuit model: </p><p>
<choiceresponse>
  <checkboxgroup>
    <choice correct="true" name="1">
      <text>Circuits are universal for classical computation</text>
    </choice>
    <choice correct="false" name="2">
      <text>Circuits are NOT a universal model for classical computation</text>
    </choice>
    <choice correct="true" name="3">
      <text>Circuits can describe computations which are beyond what a Turing machine can do</text>
    </choice>
    <choice correct="true" name="4">
      <text>Circuits can simulate Turing machines</text>
    </choice>
  </checkboxgroup>
</choiceresponse> </p></problem> </p><p>
<html display_name="" attrib_string="url_name=site_search_box1" linenum="85" tex_filename="./week1_lectures1.tex"><p>
<edxinclude linenum="85" filename="./week1_lectures1.tex">XML/add_site_search_box.xml</edxinclude> </p></html> </p></vertical> </p><p>
<vertical display_name="History of quantum mechanics and quantum computation" attrib_string="" refnum="5"><p>
<video display_name="History of quantum mechanics and quantum computation" youtube_id_1_0="Fm-gIjGlpBo" attrib_string="url_name=U1L1c"></video><html display_name="" attrib_string="url_name=site_search_box4" linenum="95" tex_filename="./week1_lectures1.tex"><p>
<edxinclude linenum="95" filename="./week1_lectures1.tex">XML/add_site_search_box.xml</edxinclude> </p></html> </p></vertical> </p><p>
<vertical display_name="CQ: Faster-than-light communication with entanglement?" attrib_string="" refnum="6"><p>
<problem display_name="Faster-than-light communication with entanglement?" attrib_string="url_name=u1-1-cq-qm-flash attempts=1" linenum="103" tex_filename="./week1_lectures1.tex"><p>
This is a concept question, provided to double-check your understanding of the previous video clip. </p><p>
As described by Prof. Shor in the last lecture video clip, in 1982, Nick Herbert published <a href="https://link.springer.com/article/10.1007%2FBF00729622" target="_blank">a paper proposing FLASH</a>, “First Laser-Amplified Superluminal Hookup," offering a means to communicate faster than the speed of light, using quantum entanglement. </p><p>
What was the flaw in Herbert's proposal? </p><p>
<multiplechoiceresponse>
  <choicegroup direction="vertical">
    <choice correct="false" name="1">
      <text> Entangled states have too short of a lifetime to allow superluminal communication</text>
    </choice>
    <choice correct="false" name="2">
      <text> Entangled photons are states of light which cannot travel faster than the speed of light</text>
    </choice>
    <choice correct="false" name="3">
      <text> Quantum entanglement involves hidden variables, which obfuscate any superluminal communication</text>
    </choice>
    <choice correct="true" name="4">
      <text> Unknown quantum states cannot be copied</text>
    </choice>
  </choicegroup>
</multiplechoiceresponse> </p></problem> </p><p>
<html display_name="" attrib_string="url_name=site_search_box5" linenum="123" tex_filename="./week1_lectures1.tex"><p>
<edxinclude linenum="123" filename="./week1_lectures1.tex">XML/add_site_search_box.xml</edxinclude> </p></html> </p></vertical> </p><p>
<vertical display_name="Computation must be robust against noise" attrib_string="" refnum="7"><p>
<video display_name="Computation must be robust against noise" youtube_id_1_0="OFWyhxzLN7k" attrib_string="url_name=U1L1d"></video><html display_name="" attrib_string="url_name=site_search_box6" linenum="133" tex_filename="./week1_lectures1.tex"><p>
<edxinclude linenum="133" filename="./week1_lectures1.tex">XML/add_site_search_box.xml</edxinclude> </p></html> </p></vertical> </p><p>
<vertical display_name="CQ: Mechanisms for fault-tolerance" attrib_string="" refnum="8"><p>
<problem display_name="Mechanisms for fault-tolerance" attrib_string="url_name=u1-1-cq-qm-flash attempts=1" linenum="141" tex_filename="./week1_lectures1.tex"><p>
This is a concept question, provided to double-check your understanding of the previous video clip. </p><p>
Which of the following are mechanisms for fault-tolerance, as used in classical computing? Check all which apply: </p><p>
<choiceresponse>
  <checkboxgroup>
    <choice correct="true" name="1">
      <text>Massive redundancy</text>
    </choice>
    <choice correct="true" name="2">
      <text>Checkpointing</text>
    </choice>
    <choice correct="false" name="3">
      <text>Code rewriting</text>
    </choice>
    <choice correct="true" name="4">
      <text>Error correction</text>
    </choice>
  </checkboxgroup>
</choiceresponse> </p></problem> </p><p>
<html display_name="" attrib_string="url_name=site_search_box7" linenum="154" tex_filename="./week1_lectures1.tex"><p>
<edxinclude linenum="154" filename="./week1_lectures1.tex">XML/add_site_search_box.xml</edxinclude> </p></html> </p></vertical> </p></sequential>  </p><p>
<sequential display_name="PS#1 Part A - Reversible Circuits" attrib_string="" linenum="3" tex_filename="./week1_2_ps1a.tex" refnum="2"><p>
<vertical display_name="Reversible two-four-three swap" attrib_string="" refnum="1"><p>
<html display_name="Classical Reversible Boolean Circuits" attrib_string="" linenum="7" tex_filename="./week1_2_ps1a.tex"><p>
<big class="xxlarge">Classical Reversible Boolean Circuits</big> </p><p>
The following problems consitute the first part of PS#1, and are due Thursday 14-Sep-2017 at 7pm ET. </p><p>
The problems explore the construction of several useful reversible circuits, using primitive reversible gates. </p><p>
For each problem, please enter a text description of the gates to apply, with one gate per line. Allowed gates include NOT, <a href="https://en.wikipedia.org/wiki/Controlled_NOT_gate" target="_blank">CNOT</a>, <a href="https://en.wikipedia.org/wiki/Toffoli_gate" target="_blank">Toffoli</a>, and <a href="https://en.wikipedia.org/wiki/Fredkin_gate" target="_blank">Fredkin</a> gates. These are some examples of how you can specify gates and which bits they act upon: <br /></p><center> <table cellspacing="0" class="tabular">
<tr>

    
    <td style="text-align:center"><p>
 <tt class="tt">not(a)</tt> </p></td>

    
    <td style="text-align:left"><p>
 NOT on a </p></td>

</tr><tr>

    
    <td style="text-align:center"><p>
<tt class="tt">cnot(a,b)</tt> </p></td>

    
    <td style="text-align:left"><p>
 CNOT with control a and target b </p></td>

</tr><tr>

    
    <td style="text-align:center"><p>
<tt class="tt">swap(c,d)</tt> </p></td>

    
    <td style="text-align:left"><p>
 swap on c,d </p></td>

</tr><tr>

    
    <td style="text-align:center"><p>
<tt class="tt">fredkin(a,b,c)</tt> </p></td>

    
    <td style="text-align:left"><p>
 Fredkin with control a and targets b,c </p></td>

</tr><tr>

    
    <td style="text-align:center"><p>
<tt class="tt">toffoli(c,a,b)</tt> </p></td>

    
    <td style="text-align:left"><p>
 Toffoli with controls c,a and target b </p></td>

</tr>
</table> </center><p>
These correspond to the following schematic drawing of the gates: <center><img src="/static/images/fig_reversible_gates.png" width="500" /></center> </p></html> </p><p>
<problem display_name="Reversible two-four-three swap" attrib_string="url_name=u1_1_four_input_cswap attempts=20" linenum="40" tex_filename="./week1_2_ps1a.tex"><p>
<edxincludepy linenum="42" filename="./week1_2_ps1a.tex">lib/ftdigital2.py</edxincludepy> </p><p>
Design a reversible circuit, using NOT, CNOT, Toffoli, and Fredkin gates, which acts on the four inputs [mathjaxinline]a, b, c, d[/mathjaxinline], to perform the operation [mathjaxinline]{\rm swap_{243}}(a,b,c,d)[/mathjaxinline] which swaps [mathjaxinline]b[/mathjaxinline] and [mathjaxinline]d[/mathjaxinline] if [mathjaxinline]a=0[/mathjaxinline], and swaps [mathjaxinline]c[/mathjaxinline] and [mathjaxinline]d[/mathjaxinline] if [mathjaxinline]a=1[/mathjaxinline]. Bit [mathjaxinline]a[/mathjaxinline] should be left unchanged. </p><p>
Note that you have 20 attempts, so you have some leeway with syntax mistakes. Most later problems will just provide 10. Work out your circuits in your own notebook and check carefully before entering; do not rely on random exploration to get the correct answer. </p><p>
<customresponse cfn="check_243_swap" expect="">
  <textbox rows="8" correct_answer=""/>
</customresponse> </p><p>
<solution><p>
<b>Solution:</b></p><span><p>
One correct solution is: </p><pre>
fredkin(a,c,d)
not(a)
fredkin(a,b,d)
not(a)
</pre><p>
<center><img src="/static/images/ps1a_swap243_circuit.png" width="500" /></center> </p></span></solution> </p><p>
<askta></askta> </p></problem> </p><p>
<html display_name="" attrib_string="url_name=site_search_box001100" linenum="79" tex_filename="./week1_2_ps1a.tex"><p>
<edxinclude linenum="79" filename="./week1_2_ps1a.tex">XML/add_site_search_box.xml</edxinclude> </p></html> </p></vertical> </p><p>
<vertical display_name="Controlled-controlled swap" attrib_string="" refnum="2"><p>
<problem display_name="Controlled-controlled swap" attrib_string="url_name=u1_1_ccswap attempts=10" linenum="88" tex_filename="./week1_2_ps1a.tex"><p>
<edxincludepy linenum="90" filename="./week1_2_ps1a.tex">lib/ftdigital2.py</edxincludepy> </p><p>
Design a reversible circuit, using NOT, CNOT, Toffoli, and Fredkin gates, which acts on the four inputs [mathjaxinline]a, b, c, d[/mathjaxinline], to swap [mathjaxinline]c[/mathjaxinline] and [mathjaxinline]d[/mathjaxinline] only when both [mathjaxinline]a=1[/mathjaxinline] and [mathjaxinline]b=1[/mathjaxinline]. You may use a fifth bit [mathjaxinline]e[/mathjaxinline], given as initialized to [mathjaxinline]e=0[/mathjaxinline], in your circuit; this bit must also end as [mathjaxinline]e=0[/mathjaxinline]. </p><p>
<customresponse cfn="check_ccswap" expect="">
  <textbox rows="8" correct_answer=""/>
</customresponse> </p><p>
<solution><p>
<b>Solution:</b></p><span><p>
One correct solution is: </p><pre>
fredkin(a,b,e)
fredkin(e,c,d)
fredkin(a,b,e)
</pre><p>
<center><img src="/static/images/ps1a_ccswap_circuit.png" width="500" /></center> </p></span></solution> </p><p>
<askta></askta> </p></problem> </p><p>
<html display_name="" attrib_string="url_name=site_search_box001101" linenum="122" tex_filename="./week1_2_ps1a.tex"><p>
<edxinclude linenum="122" filename="./week1_2_ps1a.tex">XML/add_site_search_box.xml</edxinclude> </p></html> </p></vertical> </p><p>
<vertical display_name="Reversible two-input demultiplexer" attrib_string="" refnum="3"><p>
<problem display_name="Reversible two-input demultiplexer" attrib_string="url_name=u1_1_demux2 attempts=10" linenum="130" tex_filename="./week1_2_ps1a.tex"><p>
<edxincludepy linenum="132" filename="./week1_2_ps1a.tex">lib/ftdigital2.py</edxincludepy> </p><p>
Design a reversible circuit, using NOT, CNOT, Toffoli, and Fredkin gates, which acts on the two arbitrary inputs [mathjaxinline]a, b[/mathjaxinline], and the two fixed inputs [mathjaxinline]c=0[/mathjaxinline], [mathjaxinline]d=0[/mathjaxinline], to produce four bits [mathjaxinline]a'[/mathjaxinline], [mathjaxinline]b'[/mathjaxinline], [mathjaxinline]c'[/mathjaxinline], [mathjaxinline]d'[/mathjaxinline] of output, where only the [mathjaxinline]n^{\rm th}[/mathjaxinline] output is [mathjaxinline]1[/mathjaxinline] (the others are all [mathjaxinline]0[/mathjaxinline]), and [mathjaxinline]n=2b + a[/mathjaxinline]. </p><p>
This is a two-input demultiplexer, and the output is a unary encoded value, sometimes otherwise known as <a href="https://en.wikipedia.org/wiki/One-hot" target="_blank">“one-hot encoding"</a> in the field of deep neural networks. </p><p>
<edxshowhide description="Hint"><p>
Denoting the NOT of [mathjaxinline]a[/mathjaxinline] as [mathjaxinline]\bar{a}[/mathjaxinline], note that </p><table id="a0000000002" cellpadding="7" width="100%" cellspacing="0" class="eqnarray">
<tr id="a0000000003">
    
    <td style="width:40%">&#160;</td>
    
    
        <td style="vertical-align:middle;                                    text-align:right">
	    [mathjaxinline]\displaystyle a'[/mathjaxinline]
        </td>
    
    
    
        <td style="vertical-align:middle;                                    text-align:center">
	    [mathjaxinline]\displaystyle =[/mathjaxinline]
        </td>
    
    
    
        <td style="vertical-align:middle;                                    text-align:left">
	    [mathjaxinline]\displaystyle  \bar{a} \bar{b}[/mathjaxinline]
        </td>
    
    
    
    <td style="width:40%">&#160;</td>
    <td style="width:20%" class="eqnnum"><span>(<span>1</span>)</span></td>
</tr><tr id="a0000000004">
    
    <td style="width:40%">&#160;</td>
    
    
        <td style="vertical-align:middle;                                    text-align:right">
	    [mathjaxinline]\displaystyle b'[/mathjaxinline]
        </td>
    
    
    
        <td style="vertical-align:middle;                                    text-align:center">
	    [mathjaxinline]\displaystyle =[/mathjaxinline]
        </td>
    
    
    
        <td style="vertical-align:middle;                                    text-align:left">
	    [mathjaxinline]\displaystyle  a\bar{b}[/mathjaxinline]
        </td>
    
    
    
    <td style="width:40%">&#160;</td>
    <td style="width:20%" class="eqnnum"><span>(<span>2</span>)</span></td>
</tr><tr id="a0000000005">
    
    <td style="width:40%">&#160;</td>
    
    
        <td style="vertical-align:middle;                                    text-align:right">
	    [mathjaxinline]\displaystyle c'[/mathjaxinline]
        </td>
    
    
    
        <td style="vertical-align:middle;                                    text-align:center">
	    [mathjaxinline]\displaystyle =[/mathjaxinline]
        </td>
    
    
    
        <td style="vertical-align:middle;                                    text-align:left">
	    [mathjaxinline]\displaystyle  \bar{a}b[/mathjaxinline]
        </td>
    
    
    
    <td style="width:40%">&#160;</td>
    <td style="width:20%" class="eqnnum"><span>(<span>3</span>)</span></td>
</tr><tr id="a0000000006">
    
    <td style="width:40%">&#160;</td>
    
    
        <td style="vertical-align:middle;                                    text-align:right">
	    [mathjaxinline]\displaystyle d'[/mathjaxinline]
        </td>
    
    
    
        <td style="vertical-align:middle;                                    text-align:center">
	    [mathjaxinline]\displaystyle =[/mathjaxinline]
        </td>
    
    
    
        <td style="vertical-align:middle;                                    text-align:left">
	    [mathjaxinline]\displaystyle  ab \, .[/mathjaxinline]
        </td>
    
    
    
    <td style="width:40%">&#160;</td>
    <td style="width:20%" class="eqnnum"><span>(<span>4</span>)</span></td>
</tr>
</table><p>
Since these are all Boolean functions of the input, it would seem immediate how to compute these using Boolean logic functions. The trick here is that you're being asked to construct the circuit using reversible gates, consuming no additional inputs, and producing no extra garbage. This is known as an “in-place" reversible circuit. </p><p>
You should be able to do this using 11 gates. If you can do it with fewer, let the TA know! </p></edxshowhide> </p><p>
<customresponse cfn="check_demux2" expect="">
  <textbox rows="8" correct_answer=""/>
</customresponse> </p><p>
<solution><p>
<b>Solution:</b></p><span><p>
A reasonable solution is: </p><pre>
		toffoli(a,b,d)
		not(a)
                toffoli(a,b,c)
                not(a)
                cnot(d,b)
                cnot(c,b)
                not(d)
                toffoli(a,d,b)
                not(d)
                not(a)
                cnot(c,a)
</pre><p>
<center><img src="/static/images/ps1a_demux2_circuit.png" width="500" /></center> </p></span></solution> </p><p>
<askta></askta> </p></problem> </p><p>
<html display_name="" attrib_string="url_name=site_search_box001101" linenum="199" tex_filename="./week1_2_ps1a.tex"><p>
<edxinclude linenum="199" filename="./week1_2_ps1a.tex">XML/add_site_search_box.xml</edxinclude> </p></html> </p></vertical> </p></sequential> </p><p>
<sequential display_name="PS#1 Part B - Quantum Mechanics" attrib_string="" linenum="4" tex_filename="./week1_3_ps1b.tex" refnum="3"><p>
<vertical display_name="Pauli matrices" attrib_string="" refnum="1"><p>
<problem display_name="Eigenvalues, eigenstates" attrib_string="attempts=20" linenum="8" tex_filename="./week1_3_ps1b.tex"><p>
Recall from the linear algebra class that any normal linear operator [mathjaxinline]A[/mathjaxinline] (normal linear operator satisfies [mathjaxinline]AA^{\dagger }=A^{\dagger }A[/mathjaxinline]) allows for a spectral decomposition [mathjaxinline]A=\sum _ i a_ i |{i}\rangle \! \langle {i}|[/mathjaxinline] where [mathjaxinline]a_ i[/mathjaxinline] is called eigenvalue and [mathjaxinline]|{i}\rangle[/mathjaxinline] is called eigenvector or eigenstate when [mathjaxinline]A[/mathjaxinline] is Hermitian. </p><p>
The Pauli matrices with [mathjaxinline]Z[/mathjaxinline] basis are </p><table id="a0000000007" class="equation" width="100%" cellspacing="0" cellpadding="7">
<tr>
    <td class="equation" style="width:80%">[mathjax]I= \begin{pmatrix}  1 &amp;  0\\ 0&amp;  1 \end{pmatrix} , X= \begin{pmatrix}  0 &amp;  1\\ 1&amp;  0 \end{pmatrix} , Y= \begin{pmatrix}  0 &amp;  -i\\ i&amp;  0 \end{pmatrix} , Z= \begin{pmatrix}  1 &amp;  0\\ 0&amp;  -1 \end{pmatrix}[/mathjax]</td>
    <td class="eqnnum" style="width:20%"><span>(<span>5</span>)</span></td>
</tr>
</table><p>
Compute the sets of eigenvalue and eigenstate for each Pauli matrix. Note that each Pauli matrix has a positive eigenvalue and a negative eigenvalue. Express the eigenstates with [mathjaxinline]Z[/mathjaxinline] basis ([mathjaxinline]\{ |{0}\rangle ,|{1}\rangle \}[/mathjaxinline]) using the ket notation. </p><p>
Type in <tt class="ttfamily">|0&gt;</tt> for [mathjaxinline]|{0}\rangle[/mathjaxinline] etc. and <tt class="ttfamily">sqrt(2)</tt> for [mathjaxinline]\sqrt {2}[/mathjaxinline]. For multiplication, do not forget to type <tt class="ttfamily">*</tt>. For instance, you should type in <tt class="ttfamily">2*|0&gt;</tt> for [mathjaxinline]2|{0}\rangle[/mathjaxinline]. You may use <tt class="ttfamily">i</tt> for [mathjaxinline]i[/mathjaxinline]. </p><p>
<edxincludepy linenum="45" filename="./week1_3_ps1b.tex">lib/sympy_check.py</edxincludepy> </p><p>
[mathjaxinline]X[/mathjaxinline]: <p style="display:inline">positive eigenvalue =</p> <numericalresponse inline="1" answer="1">
  <textline inline="1">
    <responseparam type="tolerance" default="1%"/>
  </textline>
</numericalresponse>, <p style="display:inline">eigenstate =</p> <customresponse cfn="sympy_check_quantum" inline="1" expect="(|0&amp;gt;+|1&amp;gt;)/sqrt(2)">
  <textline correct_answer="(|0&amp;gt;+|1&amp;gt;)/sqrt(2)" inline="1" math="1" preprocessorClassName="MathjaxPreprocessorForQM" preprocessorSrc="/static/mathjax_preprocessor_for_QM_H.js"/>
</customresponse> </p><p>
<p style="display:inline">negative eigenvalue =</p> <numericalresponse inline="1" options="" answer="-1">
  <textline inline="1">
    <responseparam type="tolerance" default="1%"/>
  </textline>
</numericalresponse>, <p style="display:inline">eigenstate =</p> <customresponse cfn="sympy_check_quantum" inline="1" expect="(|0&amp;gt;-|1&amp;gt;)/sqrt(2)">
  <textline correct_answer="(|0&amp;gt;-|1&amp;gt;)/sqrt(2)" inline="1" math="1" preprocessorClassName="MathjaxPreprocessorForQM" preprocessorSrc="/static/mathjax_preprocessor_for_QM_H.js"/>
</customresponse> </p><p>
[mathjaxinline]Y[/mathjaxinline]: <p style="display:inline">positive eigenvalue =</p> <numericalresponse inline="1" options="" answer="1">
  <textline inline="1">
    <responseparam type="tolerance" default="1%"/>
  </textline>
</numericalresponse>, <p style="display:inline">eigenstate =</p> <customresponse cfn="sympy_check_quantum" inline="1" expect="(|0&amp;gt;+i*|1&amp;gt;)/sqrt(2)">
  <textline correct_answer="(|0&amp;gt;+i*|1&amp;gt;)/sqrt(2)" inline="1" math="1" preprocessorClassName="MathjaxPreprocessorForQM" preprocessorSrc="/static/mathjax_preprocessor_for_QM_H.js"/>
</customresponse> </p><p>
<p style="display:inline">negative eigenvalue =</p> <numericalresponse inline="1" options="" answer="-1">
  <textline inline="1">
    <responseparam type="tolerance" default="1%"/>
  </textline>
</numericalresponse>, <p style="display:inline">eigenstate =</p> <customresponse cfn="sympy_check_quantum" inline="1" expect="(|0&amp;gt;-i*|1&amp;gt;)/sqrt(2)">
  <textline correct_answer="(|0&amp;gt;-i*|1&amp;gt;)/sqrt(2)" inline="1" math="1" preprocessorClassName="MathjaxPreprocessorForQM" preprocessorSrc="/static/mathjax_preprocessor_for_QM_H.js"/>
</customresponse> </p><p>
[mathjaxinline]Z[/mathjaxinline]: <p style="display:inline">positive eigenvalue =</p> <numericalresponse inline="1" options="" answer="1">
  <textline inline="1">
    <responseparam type="tolerance" default="1%"/>
  </textline>
</numericalresponse>, <p style="display:inline">eigenstate =</p> <customresponse cfn="sympy_check_quantum" inline="1" expect="|0&amp;gt;">
  <textline correct_answer="|0&amp;gt;" inline="1" math="1" preprocessorClassName="MathjaxPreprocessorForQM" preprocessorSrc="/static/mathjax_preprocessor_for_QM_H.js"/>
</customresponse> </p><p>
<p style="display:inline">negative eigenvalue =</p> <numericalresponse inline="1" options="" answer="-1">
  <textline inline="1">
    <responseparam type="tolerance" default="1%"/>
  </textline>
</numericalresponse>, <p style="display:inline">eigenstate =</p> <customresponse cfn="sympy_check_quantum" inline="1" expect="|1&amp;gt;">
  <textline correct_answer="|1&amp;gt;" inline="1" math="1" preprocessorClassName="MathjaxPreprocessorForQM" preprocessorSrc="/static/mathjax_preprocessor_for_QM_H.js"/>
</customresponse> </p><p>
<solution><p>
<b>Solution:</b></p><span><p>
All the Pauli matrices except [mathjaxinline]I[/mathjaxinline] have eigenvalues +1 and -1. Eigenvectors are in the row vector form, </p><table id="a0000000008" class="equation" width="100%" cellspacing="0" cellpadding="7">
<tr>
    <td class="equation" style="width:80%">[mathjax]X: \frac{1}{\sqrt {2}}(1,1) \mbox{ for eigenvalue +1}, \frac{1}{\sqrt {2}}(1,-1) \mbox{ for eigenvalue -1}[/mathjax]</td>
    <td class="eqnnum" style="width:20%"><span>(<span>6</span>)</span></td>
</tr>
</table><table id="a0000000009" class="equation" width="100%" cellspacing="0" cellpadding="7">
<tr>
    <td class="equation" style="width:80%">[mathjax]Y: \frac{1}{\sqrt {2}}(1,i) \mbox{ for eigenvalue +1}, \frac{1}{\sqrt {2}}(1,-i) \mbox{ for eigenvalue -1}[/mathjax]</td>
    <td class="eqnnum" style="width:20%"><span>(<span>7</span>)</span></td>
</tr>
</table><table id="a0000000010" class="equation" width="100%" cellspacing="0" cellpadding="7">
<tr>
    <td class="equation" style="width:80%">[mathjax]Z: (1,0) \mbox{ for eigenvalue +1}, (0,1) \mbox{ for eigenvalue -1}[/mathjax]</td>
    <td class="eqnnum" style="width:20%"><span>(<span>8</span>)</span></td>
</tr>
</table><p>
 Noting that [mathjaxinline]|{0}\rangle =(1,0)[/mathjaxinline] and [mathjaxinline]|{1}\rangle =(0,1)[/mathjaxinline] with [mathjaxinline]Z[/mathjaxinline] basis, the eigenstates in the ket notations are obtained. </p></span></solution> </p><p>
<askta></askta> </p></problem> </p><p>
<problem display_name="Basis changes" attrib_string="attempts=10" linenum="90" tex_filename="./week1_3_ps1b.tex"><p>
Consider the unitary matrix </p><table id="a0000000011" class="equation" width="100%" cellspacing="0" cellpadding="7">
<tr>
    <td class="equation" style="width:80%">[mathjax]H=\frac{1}{\sqrt {2}} \begin{pmatrix}  1 &amp;  1\\ 1&amp;  -1 \end{pmatrix}.[/mathjax]</td>
    <td class="eqnnum" style="width:20%"><span>(<span>9</span>)</span></td>
</tr>
</table><p>
 This important unitary is called Hadamard gate, which frequently appears in quantum circuits. It is easy to check that the Hadamard gate converts [mathjaxinline]|{0}\rangle[/mathjaxinline] and [mathjaxinline]|{1}\rangle[/mathjaxinline] as </p><table id="a0000000012" class="equation" width="100%" cellspacing="0" cellpadding="7">
<tr>
    <td class="equation" style="width:80%">[mathjax]H|{0}\rangle =\frac{1}{\sqrt {2}}(|{0}\rangle +|{1}\rangle ),\  \  H|{1}\rangle =\frac{1}{\sqrt {2}}(|{0}\rangle -|{1}\rangle ).[/mathjax]</td>
    <td class="eqnnum" style="width:20%"><span>(<span>10</span>)</span></td>
</tr>
</table><p>
 We define [mathjaxinline]|{+}\rangle =\frac{1}{\sqrt {2}}(|{0}\rangle +|{1}\rangle )[/mathjaxinline] and [mathjaxinline]|{-}\rangle =\frac{1}{\sqrt {2}}(|{0}\rangle -|{1}\rangle )[/mathjaxinline]. Express each Pauli matrix with [mathjaxinline]\{ |{+}\rangle ,|{-}\rangle \}[/mathjaxinline] basis. Type in, for instance, <tt class="ttfamily">[[1,0],[0,1]]</tt> for [mathjaxinline]\begin{pmatrix}  1 &amp;  0\\ 0 &amp;  1 \end{pmatrix}[/mathjaxinline]. </p><p>
<edxincludepy linenum="112" filename="./week1_3_ps1b.tex">lib/sympy_check.py</edxincludepy> </p><p>
[mathjaxinline]X[/mathjaxinline]: <customresponse cfn="sympy_formula_check" inline="1" expect="[[1,0],[0,-1]]">
  <textline correct_answer="[[1,0],[0,-1]]" inline="1" math="1" preprocessorClassName="MathjaxPreprocessorForQM" preprocessorSrc="/static/mathjax_preprocessor_for_QM_H.js"/>
</customresponse> </p><p>
[mathjaxinline]Y[/mathjaxinline]: <customresponse cfn="sympy_formula_check" inline="1" expect="[[0,i],[-i,0]]">
  <textline correct_answer="[[0,i],[-i,0]]" inline="1" math="1" preprocessorClassName="MathjaxPreprocessorForQM" preprocessorSrc="/static/mathjax_preprocessor_for_QM_H.js"/>
</customresponse> </p><p>
[mathjaxinline]Z[/mathjaxinline]: <customresponse cfn="sympy_formula_check" inline="1" expect="[[0,1],[1,0]]">
  <textline correct_answer="[[0,1],[1,0]]" inline="1" math="1" preprocessorClassName="MathjaxPreprocessorForQM" preprocessorSrc="/static/mathjax_preprocessor_for_QM_H.js"/>
</customresponse> </p><p>
<solution><p>
<b>Solution:</b></p><span>Using [mathjaxinline]|{+}\rangle =H|{0}\rangle[/mathjaxinline] and [mathjaxinline]|{-}\rangle =H|{1}\rangle[/mathjaxinline], <table id="a0000000013" class="equation" width="100%" cellspacing="0" cellpadding="7">
<tr>
    <td class="equation" style="width:80%">[mathjax]\langle {+}|X|{+}\rangle =\langle {0}|HXH|{0}\rangle =\langle {0}|Z|{0}\rangle =1,\  \langle {+}|X|{-}\rangle =\langle {0}|Z|{1}\rangle =0\\ \langle {-}|X|{+}\rangle =\langle {1}|Z|{0}\rangle =0,\  \langle {-}|X|{-}\rangle =\langle {1}|Z|{1}\rangle =-1\\[/mathjax]</td>
    <td class="eqnnum" style="width:20%"><span>(<span>11</span>)</span></td>
</tr>
</table> For the other two, use [mathjaxinline]HYH=-Y[/mathjaxinline], [mathjaxinline]HZH=X[/mathjaxinline]. </span></solution> </p></problem> </p></vertical> </p><p>
<vertical display_name="Quantum gates" attrib_string="" refnum="2"><p>
<problem display_name="Quantum gates" attrib_string="attempts=10" linenum="141" tex_filename="./week1_3_ps1b.tex"><p>
Quantum gates are building blocks of quantum circuits that drive the evolution of quantum states. The Hadamard gate was already introduced in the previous problem. We introduce another important gate called phase gate defined by </p><table id="a0000000014" class="equation" width="100%" cellspacing="0" cellpadding="7">
<tr>
    <td class="equation" style="width:80%">[mathjax]S= \begin{pmatrix}  1 &amp;  0 \\ 0 &amp;  i \end{pmatrix}[/mathjax]</td>
    <td class="eqnnum" style="width:20%"><span>(<span>12</span>)</span></td>
</tr>
</table><p>
 If we take the Hermitian conjugate, we obtain </p><table id="a0000000015" class="equation" width="100%" cellspacing="0" cellpadding="7">
<tr>
    <td class="equation" style="width:80%">[mathjax]S^{\dagger }= \begin{pmatrix}  1 &amp;  0 \\ 0 &amp;  -i \end{pmatrix}[/mathjax]</td>
    <td class="eqnnum" style="width:20%"><span>(<span>13</span>)</span></td>
</tr>
</table><p>
 The phase gate does not do anything to [mathjaxinline]|{0}\rangle[/mathjaxinline] but adds the phase [mathjaxinline]i[/mathjaxinline] to [mathjaxinline]|{1}\rangle[/mathjaxinline]. For instance, [mathjaxinline]S|{+}\rangle =\frac{1}{\sqrt {2}}(|{0}\rangle +i|{1}\rangle )[/mathjaxinline]. </p><p>
Quantum gates can be sequentially applied and the effective operation to the quantum state is obtained by multiplying the matrices describing the quantum gates in order. For instance, if [mathjaxinline]X[/mathjaxinline] is applied first and [mathjaxinline]H[/mathjaxinline] follows it, the total operation is [mathjaxinline]HX[/mathjaxinline]. Compute the following. </p><p>
<edxincludepy linenum="168" filename="./week1_3_ps1b.tex">lib/sympy_check.py</edxincludepy> </p><p>
<p style="display:inline">[mathjaxinline]HX=[/mathjaxinline]</p> <customresponse cfn="sympy_formula_check" inline="1" expect="(1/sqrt(2))*[[1,1],[-1,1]]">
  <textline correct_answer="(1/sqrt(2))*[[1,1],[-1,1]]" inline="1" math="1" preprocessorClassName="MathjaxPreprocessorForQM" preprocessorSrc="/static/mathjax_preprocessor_for_QM_H.js"/>
</customresponse> </p><p>
<p style="display:inline">[mathjaxinline]SH=[/mathjaxinline]</p> <customresponse cfn="sympy_formula_check" inline="1" expect="(1/sqrt(2))*[[1,1],[i,-i]]">
  <textline correct_answer="(1/sqrt(2))*[[1,1],[i,-i]]" inline="1" math="1" preprocessorClassName="MathjaxPreprocessorForQM" preprocessorSrc="/static/mathjax_preprocessor_for_QM_H.js"/>
</customresponse> </p><p>
<p style="display:inline">[mathjaxinline]SXS^{\dagger }=[/mathjaxinline]</p> <customresponse cfn="sympy_formula_check" inline="1" expect="[[0,-i],[i,0]]">
  <textline correct_answer="[[0,-i],[i,0]]" inline="1" math="1" preprocessorClassName="MathjaxPreprocessorForQM" preprocessorSrc="/static/mathjax_preprocessor_for_QM_H.js"/>
</customresponse> </p></problem> </p></vertical> </p><p>
<vertical display_name="Bloch sphere" attrib_string="" refnum="3"><p>
<problem display_name="Positions on the Bloch sphere" attrib_string="attempts=10" linenum="184" tex_filename="./week1_3_ps1b.tex"><p>
Any qubit state [mathjaxinline]|{\psi }\rangle[/mathjaxinline] can be expressed of the form </p><table id="a0000000016" class="equation" width="100%" cellspacing="0" cellpadding="7">
<tr>
    <td class="equation" style="width:80%">[mathjax]|{\psi }\rangle =\cos \left(\frac{\theta }{2}\right)|{0}\rangle +e^{i\phi }\sin \left(\frac{\theta }{2}\right)|{1}\rangle[/mathjax]</td>
    <td class="eqnnum" style="width:20%"><span>(<span>14</span>)</span></td>
</tr>
</table><p>
 up to global phases, and [mathjaxinline](\theta , \phi )[/mathjaxinline] determines the position of the state on the Bloch sphere. Express the positions in terms of [mathjaxinline](\theta , \phi )[/mathjaxinline] for the eigenstate corresponding to the [mathjaxinline]{\bf negative}[/mathjaxinline] eigenvalue of each non-identity Pauli matrix. If [mathjaxinline]\phi[/mathjaxinline] is undetermined (could take any value), take [mathjaxinline]\phi =0[/mathjaxinline]. Type in, for instance, <tt class="ttfamily">[pi,pi]</tt> for [mathjaxinline](\pi ,\pi )[/mathjaxinline]. </p><p>
<edxincludepy linenum="194" filename="./week1_3_ps1b.tex">lib/sympy_check.py</edxincludepy> </p><p>
<p style="display:inline">[mathjaxinline]X[/mathjaxinline]:</p> <customresponse cfn="sympy_formula_check" inline="1" expect="[pi/2,pi]" options="tolerance='0.01' " cfn_extra_args="options">
  <textline size="40" correct_answer="[pi/2,pi]" inline="1" math="1"/>
</customresponse> </p><p>
<p style="display:inline">[mathjaxinline]Y[/mathjaxinline]:</p> <customresponse cfn="sympy_formula_check" inline="1" expect="[pi/2,(3/2)*pi]" options="tolerance='0.01' " cfn_extra_args="options">
  <textline size="40" correct_answer="[pi/2,(3/2)*pi]" inline="1" math="1"/>
</customresponse> </p><p>
<p style="display:inline">[mathjaxinline]Z[/mathjaxinline]:</p> <customresponse cfn="sympy_formula_check" inline="1" expect="[pi,0]" options="tolerance='0.01' " cfn_extra_args="options">
  <textline size="40" correct_answer="[pi,0]" inline="1" math="1"/>
</customresponse> </p><p>
<solution><p>
<b>Solution:</b></p><span><p>
Eigenvectors corresponding to the negative eigenvalue are </p><table id="a0000000017" class="equation" width="100%" cellspacing="0" cellpadding="7">
<tr>
    <td class="equation" style="width:80%">[mathjax]X:\  \  \frac{1}{\sqrt {2}}(|{0}\rangle -|{1}\rangle ),\  \  (\theta ,\phi )=(\pi /2,\pi )\\ Y:\  \  \frac{1}{\sqrt {2}}(|{0}\rangle -i|{1}\rangle ),\  \  (\theta ,\phi )=(\pi /2,3\pi /2)\\ Z:\  \  |{1}\rangle ,\  \  (\theta ,\phi )=(\pi ,\mbox{undertmined})[/mathjax]</td>
    <td class="eqnnum" style="width:20%"><span>(<span>15</span>)</span></td>
</tr>
</table></span></solution> </p></problem> </p><p>
<problem display_name="Single qubit rotation" attrib_string="attempts=10" linenum="215" tex_filename="./week1_3_ps1b.tex"><p>
Any unitary matrix in [mathjaxinline]SU(2)[/mathjaxinline] can be written of the form </p><table id="a0000000018" class="equation" width="100%" cellspacing="0" cellpadding="7">
<tr>
    <td class="equation" style="width:80%">[mathjax]U=e^{-i\frac{\theta }{2} \vec{n}\cdot \vec{\sigma }}=\cos \left(\frac{\theta }{2}\right)I - i\sin \left(\frac{\theta }{2}\right)\vec{n}\cdot \vec{\sigma }[/mathjax]</td>
    <td class="eqnnum" style="width:20%"><span>(<span>16</span>)</span></td>
</tr>
</table><p>
 It is regarded as a rotational operation on the Bloch sphere where [mathjaxinline]\theta[/mathjaxinline] and [mathjaxinline]\vec{n}=(n_ x,n_ y,n_ z)[/mathjaxinline] specify the rotation angle and the axis which which the rotation takes place. [mathjaxinline]\vec{n}[/mathjaxinline] is a unit vector satisfying [mathjaxinline]n_ x^2+n_ y^2+n_ z^2=1[/mathjaxinline]. Note that [mathjaxinline]\vec{n}\cdot \vec{\sigma }=n_ x\sigma _ x+n_ y\sigma _ y+n_ z\sigma _ z[/mathjaxinline]. We take [mathjaxinline]n_ x\geq 0[/mathjaxinline] and [mathjaxinline]0\leq \theta &lt;2\pi[/mathjaxinline] without loss of generality. Find [mathjaxinline]\vec{n}[/mathjaxinline] and [mathjaxinline]\theta[/mathjaxinline] for the following unitary matrices. Type in, for instance, <tt class="ttfamily">[0,0,1]</tt> for [mathjaxinline](0,0,1)[/mathjaxinline]. You may use <tt class="ttfamily">sqrt(2)</tt> for [mathjaxinline]\sqrt {2}[/mathjaxinline]. </p><p>
<edxincludepy linenum="225" filename="./week1_3_ps1b.tex">lib/sympy_check.py</edxincludepy> </p><p>
[mathjaxinline]X[/mathjaxinline]: <p style="display:inline">[mathjaxinline]\vec{n}=[/mathjaxinline]</p><customresponse cfn="sympy_formula_check" inline="1" expect="[1,0,0]" options="tolerance='0.01' " cfn_extra_args="options">
  <textline size="40" correct_answer="[1,0,0]" inline="1" math="1"/>
</customresponse> <p style="display:inline">[mathjaxinline]\theta =[/mathjaxinline]</p><customresponse cfn="sympy_formula_check" inline="1" expect="pi" options="tolerance='0.01' " cfn_extra_args="options">
  <textline size="40" correct_answer="pi" inline="1" math="1"/>
</customresponse> </p><p>
[mathjaxinline]H=\frac{1}{\sqrt {2}} \begin{pmatrix}  1 &amp;  1\\ 1 &amp;  -1 \end{pmatrix}[/mathjaxinline]: <p style="display:inline">[mathjaxinline]\vec{n}=[/mathjaxinline]</p><customresponse cfn="sympy_formula_check" inline="1" expect="[1/sqrt(2),0,1/sqrt(2)]" options="tolerance='0.01' " cfn_extra_args="options">
  <textline size="40" correct_answer="[1/sqrt(2),0,1/sqrt(2)]" inline="1" math="1"/>
</customresponse> <p style="display:inline">[mathjaxinline]\theta =[/mathjaxinline]</p><customresponse cfn="sympy_formula_check" inline="1" expect="pi" options="tolerance='0.01' " cfn_extra_args="options">
  <textline size="40" correct_answer="pi" inline="1" math="1"/>
</customresponse> </p><p>
[mathjaxinline]S= \begin{pmatrix}  1 &amp;  0\\ 0 &amp;  i \end{pmatrix}[/mathjaxinline]: <p style="display:inline">[mathjaxinline]\vec{n}=[/mathjaxinline]</p><customresponse cfn="sympy_formula_check" inline="1" expect="[0,0,1]" options="tolerance='0.01' " cfn_extra_args="options">
  <textline size="40" correct_answer="[0,0,1]" inline="1" math="1"/>
</customresponse> <p style="display:inline">[mathjaxinline]\theta =[/mathjaxinline]</p><customresponse cfn="sympy_formula_check" inline="1" expect="pi/2" options="tolerance='0.01' " cfn_extra_args="options">
  <textline size="40" correct_answer="pi/2" inline="1" math="1"/>
</customresponse> </p><p>
[mathjaxinline]SH[/mathjaxinline]: <p style="display:inline">[mathjaxinline]\vec{n}=[/mathjaxinline]</p><customresponse cfn="sympy_formula_check" inline="1" expect="[1/sqrt(3),1/sqrt(3),1/sqrt(3)]" options="tolerance='0.01' " cfn_extra_args="options">
  <textline size="40" correct_answer="[1/sqrt(3),1/sqrt(3),1/sqrt(3)]" inline="1" math="1"/>
</customresponse> <p style="display:inline">[mathjaxinline]\theta =[/mathjaxinline]</p><customresponse cfn="sympy_formula_check" inline="1" expect="(4/3)*pi" options="tolerance='0.01' " cfn_extra_args="options">
  <textline size="40" correct_answer="(4/3)*pi" inline="1" math="1"/>
</customresponse> </p><p>
<solution><p>
<b>Solution:</b></p><span><p>
[mathjaxinline]U=e^{-i\frac{\theta }{2}\vec{n}\cdot \sigma }[/mathjaxinline] can be explicitly written as </p><table id="a0000000019" class="equation" width="100%" cellspacing="0" cellpadding="7">
<tr>
    <td class="equation" style="width:80%">[mathjax]U=\begin{pmatrix}  \cos (\theta /2)-i\sin (\theta /2)n_ z &amp;  -i\sin (\theta /2)n_ x-\sin (\theta /2)n_ y\\ -i\sin (\theta /2)n_ x+\sin (\theta /2)n_ y &amp;  \cos (\theta /2)+i\sin (\theta /2)n_ z \end{pmatrix}[/mathjax]</td>
    <td class="eqnnum" style="width:20%"><span>(<span>17</span>)</span></td>
</tr>
</table><p>
We will see the first one closely. All the others can be obtained in similar ways. [mathjaxinline]X=\begin{pmatrix}  0 &amp;  1\\ 1 &amp;  0 \end{pmatrix}[/mathjaxinline]<br />[mathjaxinline]n_ z=0[/mathjaxinline] because the diagonal entries are zero. Equating the real part and imaginary part of [mathjaxinline](1,2)[/mathjaxinline] entry and [mathjaxinline](2,1)[/mathjaxinline] entry gives [mathjaxinline]n_ x=1,n_ y=0[/mathjaxinline], and [mathjaxinline]\theta =\pi[/mathjaxinline]. [mathjaxinline]\vec{n}=(1,0,0)[/mathjaxinline] and [mathjaxinline]\theta =\pi[/mathjaxinline] gives [mathjaxinline]U=-iX[/mathjaxinline]. Since the global phase does not play any role, we do not have to worry about [mathjaxinline]-i[/mathjaxinline] part. We say that [mathjaxinline]U[/mathjaxinline] is equivalent to [mathjaxinline]X[/mathjaxinline] up to global phases. </p></span></solution> </p></problem> </p><p>
<problem display_name="Single qubit rotation" attrib_string="attempts=10" linenum="273" tex_filename="./week1_3_ps1b.tex"><p>
What are the resulting positions when the following unitaries are applied to the state positioned [mathjaxinline](\pi /2, 0)[/mathjaxinline]? Answer in terms of [mathjaxinline](\theta , \phi )[/mathjaxinline]. Take [mathjaxinline]\phi =0[/mathjaxinline] when [mathjaxinline]\phi[/mathjaxinline] is not determined (could take any value). </p><p>
<edxincludepy linenum="278" filename="./week1_3_ps1b.tex">lib/sympy_check.py</edxincludepy> </p><p>
[mathjaxinline]X:[/mathjaxinline] <customresponse cfn="sympy_formula_check" inline="1" expect="[pi/2,0]" options="tolerance='0.01' " cfn_extra_args="options">
  <textline size="40" correct_answer="[pi/2,0]" inline="1" math="1"/>
</customresponse> </p><p>
[mathjaxinline]S:[/mathjaxinline] <customresponse cfn="sympy_formula_check" inline="1" expect="[pi/2,pi/2]" options="tolerance='0.01' " cfn_extra_args="options">
  <textline size="40" correct_answer="[pi/2,pi/2]" inline="1" math="1"/>
</customresponse> </p><p>
[mathjaxinline]SH:[/mathjaxinline] <customresponse cfn="sympy_formula_check" inline="1" expect="[0,0]" options="tolerance='0.01' " cfn_extra_args="options">
  <textline size="40" correct_answer="[0,0]" inline="1" math="1"/>
</customresponse> </p><p>
[mathjaxinline]SHSH:[/mathjaxinline] <customresponse cfn="sympy_formula_check" inline="1" expect="[pi/2,pi]" options="tolerance='0.01' " cfn_extra_args="options">
  <textline size="40" correct_answer="[pi/2,pi]" inline="1" math="1"/>
</customresponse> </p><p>
See how these gates rotate quantum states on the Bloch sphere and especially permute the eigenstates of Pauli matrices. </p><p>
<solution><p>
<b>Solution:</b></p><span><p>
The state corresponding to [mathjaxinline](\pi /2,0)[/mathjaxinline] is [mathjaxinline]|{+}\rangle =\frac{1}{2}(|{0}\rangle +|{1}\rangle )[/mathjaxinline]. Apply the unitaries to it and find [mathjaxinline]\theta[/mathjaxinline] and [mathjaxinline]\phi[/mathjaxinline] such that [mathjaxinline]U|{+}\rangle =\cos (\theta /2)+e^{i\phi }\sin (\theta /2)[/mathjaxinline]. </p></span></solution> </p></problem> </p></vertical> </p></sequential>  </p></chapter>  </p></course> </p></div>





<div class="navigation">



</div>

</document>