<document>

<div class="navigation">



</div>

<div><p>
<course number="8.370r" display_name="Quantum Info Science I" attrib_string="semester=2017_Fall"><p>
<chapter display_name="Unit 1: Quantum and classical computing fundamentals" attrib_string="url_name=unit1" linenum="39" tex_filename="./week1.tex" refnum="1"><p>
<askta>settings=1 to=rtakagi@mit.edu cc=ichuang@mit.edu</askta> </p><p>
<sequential display_name="Lectures U1.1: History and development of quantum computation" attrib_string="" linenum="3" tex_filename="./week1_lectures1.tex" refnum="1"><p>
<vertical display_name="About Unit 1" attrib_string="" refnum="1"><p>
<html display_name="About Unit 1" attrib_string="" linenum="9" tex_filename="./week1_lectures1.tex"><p>
<big class="xxlarge">About Unit 1</big> </p><p>
<b class="bf">Lecture Topics:</b> Introduction to quantum computation; classical Boolean logic; introduction to quantum mechanics; quantum wierdness. </p><p>
We begin this course with an overview of quantum computation, then build a foundation for the semester by describing the basic tenets of classical computing, based on Boolean logic. We then present the fundamental principles of quantum mechanics, in the context of quantum computation, based on four postulates governing states, time-evolution of states, measurement, and tensor products of states. We then illustrate some of the strangest, non-classical features of quantum mechanics, many of which arise in the context of a property known as quantum entanglement. </p><p>
 <br /><b class="bf">Optional Reading:</b> <a href="https://www.amazon.com/Quantum-Computation-Information-10th-Anniversary/dp/1107002176" target="_blank">Nielsen and Chuang</a>, Chapter 1 </p></html> </p><p>
<html display_name="" attrib_string="url_name=site_search_box1" linenum="35" tex_filename="./week1_lectures1.tex"><p>
<edxinclude linenum="35" filename="./week1_lectures1.tex">XML/add_site_search_box.xml</edxinclude> </p></html> </p></vertical> </p><p>
<vertical display_name="Course topics for the semester" attrib_string="" refnum="2"><p>
<video display_name="Course topics for the semester" youtube_id_1_0="mkEzEkrqrlk" attrib_string="url_name=U1L1a"></video><html display_name="" attrib_string="url_name=site_search_box2" linenum="45" tex_filename="./week1_lectures1.tex"><p>
<edxinclude linenum="45" filename="./week1_lectures1.tex">XML/add_site_search_box.xml</edxinclude> </p></html> </p></vertical> </p><p>
<vertical display_name="Models for classical computation" attrib_string="" refnum="3"><p>
<video display_name="Models for classical computation" youtube_id_1_0="BM4hlDQsc1M" attrib_string="url_name=U1L1b"></video><html display_name="" attrib_string="url_name=site_search_box3" linenum="57" tex_filename="./week1_lectures1.tex"><p>
<edxinclude linenum="57" filename="./week1_lectures1.tex">XML/add_site_search_box.xml</edxinclude> </p></html> </p></vertical> </p><p>
<vertical display_name="CQ: Models for classical computation" attrib_string="" refnum="4"><p>
<problem display_name="Universality of classical circuits" attrib_string="url_name=u1-1-cq-universality attempts=1" linenum="65" tex_filename="./week1_lectures1.tex"><p>
This is a concept question, provided to double-check your understanding of the previous video clip. </p><p>
In lecture, Prof. Shor introduced the topic of universality, and described how some models of classical computation which are universal, and other models are not. </p><p>
The circuit model of classical computation may be defined as the family of electrical circuits composed from AND gates and NOT gates. </p><p>
Check all the following which are true for the circuit model: </p><p>
<choiceresponse>
  <checkboxgroup>
    <choice correct="true" name="1">
      <text>Circuits are universal for classical computation</text>
    </choice>
    <choice correct="false" name="2">
      <text>Circuits are NOT a universal model for classical computation</text>
    </choice>
    <choice correct="true" name="3">
      <text>Circuits can describe computations which are beyond what a Turing machine can do</text>
    </choice>
    <choice correct="true" name="4">
      <text>Circuits can simulate Turing machines</text>
    </choice>
  </checkboxgroup>
</choiceresponse> </p></problem> </p><p>
<html display_name="" attrib_string="url_name=site_search_box1" linenum="85" tex_filename="./week1_lectures1.tex"><p>
<edxinclude linenum="85" filename="./week1_lectures1.tex">XML/add_site_search_box.xml</edxinclude> </p></html> </p></vertical> </p><p>
<vertical display_name="History of quantum mechanics and quantum computation" attrib_string="" refnum="5"><p>
<video display_name="History of quantum mechanics and quantum computation" youtube_id_1_0="Fm-gIjGlpBo" attrib_string="url_name=U1L1c"></video><html display_name="" attrib_string="url_name=site_search_box4" linenum="95" tex_filename="./week1_lectures1.tex"><p>
<edxinclude linenum="95" filename="./week1_lectures1.tex">XML/add_site_search_box.xml</edxinclude> </p></html> </p></vertical> </p><p>
<vertical display_name="CQ: Faster-than-light communication with entanglement?" attrib_string="" refnum="6"><p>
<problem display_name="Faster-than-light communication with entanglement?" attrib_string="url_name=u1-1-cq-qm-flash attempts=1" linenum="103" tex_filename="./week1_lectures1.tex"><p>
This is a concept question, provided to double-check your understanding of the previous video clip. </p><p>
As described by Prof. Shor in the last lecture video clip, in 1982, Nick Herbert published <a href="https://link.springer.com/article/10.1007%2FBF00729622" target="_blank">a paper proposing FLASH</a>, “First Laser-Amplified Superluminal Hookup," offering a means to communicate faster than the speed of light, using quantum entanglement. </p><p>
What was the flaw in Herbert's proposal? </p><p>
<multiplechoiceresponse>
  <choicegroup direction="vertical">
    <choice correct="false" name="1">
      <text> Entangled states have too short of a lifetime to allow superluminal communication</text>
    </choice>
    <choice correct="false" name="2">
      <text> Entangled photons are states of light which cannot travel faster than the speed of light</text>
    </choice>
    <choice correct="false" name="3">
      <text> Quantum entanglement involves hidden variables, which obfuscate any superluminal communication</text>
    </choice>
    <choice correct="true" name="4">
      <text> Unknown quantum states cannot be copied</text>
    </choice>
  </choicegroup>
</multiplechoiceresponse> </p></problem> </p><p>
<html display_name="" attrib_string="url_name=site_search_box5" linenum="123" tex_filename="./week1_lectures1.tex"><p>
<edxinclude linenum="123" filename="./week1_lectures1.tex">XML/add_site_search_box.xml</edxinclude> </p></html> </p></vertical> </p><p>
<vertical display_name="Computation must be robust against noise" attrib_string="" refnum="7"><p>
<video display_name="Computation must be robust against noise" youtube_id_1_0="OFWyhxzLN7k" attrib_string="url_name=U1L1d"></video><html display_name="" attrib_string="url_name=site_search_box6" linenum="133" tex_filename="./week1_lectures1.tex"><p>
<edxinclude linenum="133" filename="./week1_lectures1.tex">XML/add_site_search_box.xml</edxinclude> </p></html> </p></vertical> </p><p>
<vertical display_name="CQ: Mechanisms for fault-tolerance" attrib_string="" refnum="8"><p>
<problem display_name="Mechanisms for fault-tolerance" attrib_string="url_name=u1-1-cq-qm-flash attempts=1" linenum="141" tex_filename="./week1_lectures1.tex"><p>
This is a concept question, provided to double-check your understanding of the previous video clip. </p><p>
Which of the following are mechanisms for fault-tolerance, as used in classical computing? Check all which apply: </p><p>
<choiceresponse>
  <checkboxgroup>
    <choice correct="true" name="1">
      <text>Massive redundancy</text>
    </choice>
    <choice correct="true" name="2">
      <text>Checkpointing</text>
    </choice>
    <choice correct="false" name="3">
      <text>Code rewriting</text>
    </choice>
    <choice correct="true" name="4">
      <text>Error correction</text>
    </choice>
  </checkboxgroup>
</choiceresponse> </p></problem> </p><p>
<html display_name="" attrib_string="url_name=site_search_box7" linenum="154" tex_filename="./week1_lectures1.tex"><p>
<edxinclude linenum="154" filename="./week1_lectures1.tex">XML/add_site_search_box.xml</edxinclude> </p></html> </p></vertical> </p></sequential>  </p><p>
<sequential display_name="PS#1 Part A - Reversible Circuits" attrib_string="" linenum="3" tex_filename="./week1_2_ps1a.tex" refnum="2"><p>
<vertical display_name="Reversible two-four-three swap" attrib_string="" refnum="1"><p>
<html display_name="Classical Reversible Boolean Circuits" attrib_string="" linenum="7" tex_filename="./week1_2_ps1a.tex"><p>
<big class="xxlarge">Classical Reversible Boolean Circuits</big> </p><p>
The following problems consitute the first part of PS#1, and are due Thursday 14-Sep-2017 at 7pm ET. </p><p>
The problems explore the construction of several useful reversible circuits, using primitive reversible gates. </p><p>
For each problem, please enter a text description of the gates to apply, with one gate per line. Allowed gates include NOT, <a href="https://en.wikipedia.org/wiki/Controlled_NOT_gate" target="_blank">CNOT</a>, <a href="https://en.wikipedia.org/wiki/Toffoli_gate" target="_blank">Toffoli</a>, and <a href="https://en.wikipedia.org/wiki/Fredkin_gate" target="_blank">Fredkin</a> gates. These are some examples of how you can specify gates and which bits they act upon: <br /></p><center> <table cellspacing="0" class="tabular">
<tr>

    
    <td style="text-align:center"><p>
 <tt class="tt">not(a)</tt> </p></td>

    
    <td style="text-align:left"><p>
 NOT on a </p></td>

</tr><tr>

    
    <td style="text-align:center"><p>
<tt class="tt">cnot(a,b)</tt> </p></td>

    
    <td style="text-align:left"><p>
 CNOT with control a and target b </p></td>

</tr><tr>

    
    <td style="text-align:center"><p>
<tt class="tt">swap(c,d)</tt> </p></td>

    
    <td style="text-align:left"><p>
 swap on c,d </p></td>

</tr><tr>

    
    <td style="text-align:center"><p>
<tt class="tt">fredkin(a,b,c)</tt> </p></td>

    
    <td style="text-align:left"><p>
 Fredkin with control a and targets b,c </p></td>

</tr><tr>

    
    <td style="text-align:center"><p>
<tt class="tt">toffoli(c,a,b)</tt> </p></td>

    
    <td style="text-align:left"><p>
 Toffoli with controls c,a and target b </p></td>

</tr>
</table> </center><p>
These correspond to the following schematic drawing of the gates: <center><img src="/static/images/fig_reversible_gates.png" width="500" /></center> </p></html> </p><p>
<problem display_name="Reversible two-four-three swap" attrib_string="url_name=u1_1_four_input_cswap attempts=20" linenum="40" tex_filename="./week1_2_ps1a.tex"><p>
<edxincludepy linenum="42" filename="./week1_2_ps1a.tex">lib/ftdigital2.py</edxincludepy> </p><p>
Design a reversible circuit, using NOT, CNOT, Toffoli, and Fredkin gates, which acts on the four inputs [mathjaxinline]a, b, c, d[/mathjaxinline], to perform the operation [mathjaxinline]{\rm swap_{243}}(a,b,c,d)[/mathjaxinline] which swaps [mathjaxinline]b[/mathjaxinline] and [mathjaxinline]d[/mathjaxinline] if [mathjaxinline]a=0[/mathjaxinline], and swaps [mathjaxinline]c[/mathjaxinline] and [mathjaxinline]d[/mathjaxinline] if [mathjaxinline]a=1[/mathjaxinline]. Bit [mathjaxinline]a[/mathjaxinline] should be left unchanged. </p><p>
Note that you have 20 attempts, so you have some leeway with syntax mistakes. Most later problems will just provide 10. Work out your circuits in your own notebook and check carefully before entering; do not rely on random exploration to get the correct answer. </p><p>
<customresponse cfn="check_243_swap" expect="">
  <textbox rows="8" correct_answer=""/>
</customresponse> </p><p>
<solution><p>
<b>Solution:</b></p><span><p>
One correct solution is: </p><pre>
fredkin(a,c,d)
not(a)
fredkin(a,b,d)
not(a)
</pre><p>
<center><img src="/static/images/ps1a_swap243_circuit.png" width="500" /></center> </p></span></solution> </p><p>
<askta></askta> </p></problem> </p><p>
<html display_name="" attrib_string="url_name=site_search_box001100" linenum="79" tex_filename="./week1_2_ps1a.tex"><p>
<edxinclude linenum="79" filename="./week1_2_ps1a.tex">XML/add_site_search_box.xml</edxinclude> </p></html> </p></vertical> </p><p>
<vertical display_name="Controlled-controlled swap" attrib_string="" refnum="2"><p>
<problem display_name="Controlled-controlled swap" attrib_string="url_name=u1_1_ccswap attempts=10" linenum="88" tex_filename="./week1_2_ps1a.tex"><p>
<edxincludepy linenum="90" filename="./week1_2_ps1a.tex">lib/ftdigital2.py</edxincludepy> </p><p>
Design a reversible circuit, using NOT, CNOT, Toffoli, and Fredkin gates, which acts on the four inputs [mathjaxinline]a, b, c, d[/mathjaxinline], to swap [mathjaxinline]c[/mathjaxinline] and [mathjaxinline]d[/mathjaxinline] only when both [mathjaxinline]a=1[/mathjaxinline] and [mathjaxinline]b=1[/mathjaxinline]. You may use a fifth bit [mathjaxinline]e[/mathjaxinline], given as initialized to [mathjaxinline]e=0[/mathjaxinline], in your circuit; this bit must also end as [mathjaxinline]e=0[/mathjaxinline]. </p><p>
<customresponse cfn="check_ccswap" expect="">
  <textbox rows="8" correct_answer=""/>
</customresponse> </p><p>
<solution><p>
<b>Solution:</b></p><span><p>
One correct solution is: </p><pre>
fredkin(a,b,e)
fredkin(e,c,d)
fredkin(a,b,e)
</pre><p>
<center><img src="/static/images/ps1a_ccswap_circuit.png" width="500" /></center> </p></span></solution> </p><p>
<askta></askta> </p></problem> </p><p>
<html display_name="" attrib_string="url_name=site_search_box001101" linenum="122" tex_filename="./week1_2_ps1a.tex"><p>
<edxinclude linenum="122" filename="./week1_2_ps1a.tex">XML/add_site_search_box.xml</edxinclude> </p></html> </p></vertical> </p><p>
<vertical display_name="Reversible two-input demultiplexer" attrib_string="" refnum="3"><p>
<problem display_name="Reversible two-input demultiplexer" attrib_string="url_name=u1_1_demux2 attempts=10" linenum="130" tex_filename="./week1_2_ps1a.tex"><p>
<edxincludepy linenum="132" filename="./week1_2_ps1a.tex">lib/ftdigital2.py</edxincludepy> </p><p>
Design a reversible circuit, using NOT, CNOT, Toffoli, and Fredkin gates, which acts on the two arbitrary inputs [mathjaxinline]a, b[/mathjaxinline], and the two fixed inputs [mathjaxinline]c=0[/mathjaxinline], [mathjaxinline]d=0[/mathjaxinline], to produce four bits [mathjaxinline]a'[/mathjaxinline], [mathjaxinline]b'[/mathjaxinline], [mathjaxinline]c'[/mathjaxinline], [mathjaxinline]d'[/mathjaxinline] of output, where only the [mathjaxinline]n^{\rm th}[/mathjaxinline] output is [mathjaxinline]1[/mathjaxinline] (the others are all [mathjaxinline]0[/mathjaxinline]), and [mathjaxinline]n=2b + a[/mathjaxinline]. </p><p>
This is a two-input demultiplexer, and the output is a unary encoded value, sometimes otherwise known as <a href="https://en.wikipedia.org/wiki/One-hot" target="_blank">“one-hot encoding"</a> in the field of deep neural networks. </p><p>
<edxshowhide description="Hint"><p>
Denoting the NOT of [mathjaxinline]a[/mathjaxinline] as [mathjaxinline]\bar{a}[/mathjaxinline], note that </p><table id="a0000000002" cellpadding="7" width="100%" cellspacing="0" class="eqnarray">
<tr id="a0000000003">
    
    <td style="width:40%">&#160;</td>
    
    
        <td style="vertical-align:middle;                                    text-align:right">
	    [mathjaxinline]\displaystyle a'[/mathjaxinline]
        </td>
    
    
    
        <td style="vertical-align:middle;                                    text-align:center">
	    [mathjaxinline]\displaystyle =[/mathjaxinline]
        </td>
    
    
    
        <td style="vertical-align:middle;                                    text-align:left">
	    [mathjaxinline]\displaystyle  \bar{a} \bar{b}[/mathjaxinline]
        </td>
    
    
    
    <td style="width:40%">&#160;</td>
    <td style="width:20%" class="eqnnum"><span>(<span>1</span>)</span></td>
</tr><tr id="a0000000004">
    
    <td style="width:40%">&#160;</td>
    
    
        <td style="vertical-align:middle;                                    text-align:right">
	    [mathjaxinline]\displaystyle b'[/mathjaxinline]
        </td>
    
    
    
        <td style="vertical-align:middle;                                    text-align:center">
	    [mathjaxinline]\displaystyle =[/mathjaxinline]
        </td>
    
    
    
        <td style="vertical-align:middle;                                    text-align:left">
	    [mathjaxinline]\displaystyle  a\bar{b}[/mathjaxinline]
        </td>
    
    
    
    <td style="width:40%">&#160;</td>
    <td style="width:20%" class="eqnnum"><span>(<span>2</span>)</span></td>
</tr><tr id="a0000000005">
    
    <td style="width:40%">&#160;</td>
    
    
        <td style="vertical-align:middle;                                    text-align:right">
	    [mathjaxinline]\displaystyle c'[/mathjaxinline]
        </td>
    
    
    
        <td style="vertical-align:middle;                                    text-align:center">
	    [mathjaxinline]\displaystyle =[/mathjaxinline]
        </td>
    
    
    
        <td style="vertical-align:middle;                                    text-align:left">
	    [mathjaxinline]\displaystyle  \bar{a}b[/mathjaxinline]
        </td>
    
    
    
    <td style="width:40%">&#160;</td>
    <td style="width:20%" class="eqnnum"><span>(<span>3</span>)</span></td>
</tr><tr id="a0000000006">
    
    <td style="width:40%">&#160;</td>
    
    
        <td style="vertical-align:middle;                                    text-align:right">
	    [mathjaxinline]\displaystyle d'[/mathjaxinline]
        </td>
    
    
    
        <td style="vertical-align:middle;                                    text-align:center">
	    [mathjaxinline]\displaystyle =[/mathjaxinline]
        </td>
    
    
    
        <td style="vertical-align:middle;                                    text-align:left">
	    [mathjaxinline]\displaystyle  ab \, .[/mathjaxinline]
        </td>
    
    
    
    <td style="width:40%">&#160;</td>
    <td style="width:20%" class="eqnnum"><span>(<span>4</span>)</span></td>
</tr>
</table><p>
Since these are all Boolean functions of the input, it would seem immediate how to compute these using Boolean logic functions. The trick here is that you're being asked to construct the circuit using reversible gates, consuming no additional inputs, and producing no extra garbage. This is known as an “in-place" reversible circuit. </p><p>
You should be able to do this using 11 gates. If you can do it with fewer, let the TA know! </p></edxshowhide> </p><p>
<customresponse cfn="check_demux2" expect="">
  <textbox rows="8" correct_answer=""/>
</customresponse> </p><p>
<solution><p>
<b>Solution:</b></p><span><p>
A reasonable solution is: </p><pre>
		toffoli(a,b,d)
		not(a)
                toffoli(a,b,c)
                not(a)
                cnot(d,b)
                cnot(c,b)
                not(d)
                toffoli(a,d,b)
                not(d)
                not(a)
                cnot(c,a)
</pre><p>
<center><img src="/static/images/ps1a_demux2_circuit.png" width="500" /></center> </p></span></solution> </p><p>
<askta></askta> </p></problem> </p><p>
<html display_name="" attrib_string="url_name=site_search_box001101" linenum="199" tex_filename="./week1_2_ps1a.tex"><p>
<edxinclude linenum="199" filename="./week1_2_ps1a.tex">XML/add_site_search_box.xml</edxinclude> </p></html> </p></vertical> </p></sequential> </p></chapter>  </p></course> </p></div>





<div class="navigation">



</div>

</document>